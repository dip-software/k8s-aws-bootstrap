apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: argocd
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "1"
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    repoURL: oci://ghcr.io/argoproj/argo-helm/argo-cd
    # renovate: datasource=github-releases depName=argoproj/argo-helm
    targetRevision: 8.6.3
    path: .
    helm:
      valuesObject:    
        global:
          domain: "argocd.${CLUSTER_FQDN}"
          # Enable high availability mode
          ha:
            enabled: false

        # Configs
        configs:
          params:
            application.namespaces: "*"
          cm:
            application.resourceTrackingMethod: annotation
            resource.customizations: |
              # Crossplane resources health check
              argoproj.io/Application:
                health.lua: ""
              
              # Crossplane custom resources
              pkg.crossplane.io/*:
                health.lua: |
                  -- Source: https://docs.crossplane.io/latest/guides/crossplane-with-argo-cd/
                  -- Default health status for resources being provisioned
                  local DEFAULT_HEALTH_STATUS = {
                    status = "Progressing",
                    message = "Provisioningâ€¦"
                  }
                  
                  -- Health status constants
                  local HEALTH_STATUS = {
                    HEALTHY = "Healthy",
                    DEGRADED = "Degraded",
                    PROGRESSING = "Progressing"
                  }
                  
                  -- Resource kinds that don't have status conditions but are considered healthy by default
                  local RESOURCES_WITHOUT_STATUS = {
                    "Composition",
                    "CompositionRevision", 
                    "ControllerConfig",
                    "DeploymentRuntimeConfig",
                    "EnvironmentConfig",
                    "ProviderConfig",
                    "ProviderConfigUsage"
                  }
                  
                  local REVISION_CHECK_KINDS = {
                    "FunctionRevision",
                    "ProviderRevision",
                    "CompositionRevision"
                  }

                  -- Condition types that indicate a healthy resource
                  local HEALTHY_CONDITION_TYPES = {
                    "Ready",
                    "Healthy", 
                    "Offered",
                    "Established"
                  }
                  
                  -- Critical condition types that affect resource health
                  local CRITICAL_CONDITION_TYPES = {
                    "LastAsyncOperation",
                    "Synced"
                  }
                  
                  -- Utility function to check if a value exists in a table
                  local function contains(table, val)
                    if not table or not val then
                      return false
                    end
                    
                    for _, v in ipairs(table) do
                      if v == val then
                        return true
                      end
                    end
                    return false
                  end
                  
                  -- Create a health status response
                  local function create_health_status(status, message)
                    return {
                      status = status,
                      message = message or ""
                    }
                  end
                  
                  -- Handle resources that don't have status by design
                  local function handle_resources_without_status()
                    if not obj or not obj.kind then
                      return nil
                    end
                    
                    if obj.status == nil and contains(RESOURCES_WITHOUT_STATUS, obj.kind) then
                      return create_health_status(HEALTH_STATUS.HEALTHY, "Resource is up-to-date.")
                    end
                    
                    return nil
                  end
                  
                  -- Handle resources without status conditions but with other status fields
                  local function handle_resources_with_revision_checks()
                    if contains(REVISION_CHECK_KINDS, obj.kind) then
                      if not obj.status or not obj.status.conditions then
                        return nil
                      end
                      local revision_healthy = false
                      local runtime_healthy = false
                      for i, condition in ipairs(obj.status.conditions) do
                        if condition.type == "RevisionHealthy" and condition.status == "True" then
                          revision_healthy = true
                        end
                        if condition.type == "RuntimeHealthy" and condition.status == "True" then
                          runtime_healthy = true
                        end
                      end
                      if revision_healthy and runtime_healthy then
                        return create_health_status(HEALTH_STATUS.HEALTHY, "Resource is up-to-date.")
                      end
                    end

                    return nil
                  end

                  -- Handle ProviderConfig resources specially
                  local function handle_provider_config()
                    if not obj or obj.kind ~= "ProviderConfig" then
                      return nil
                    end
                    
                    if obj.status == nil or obj.status.conditions == nil then
                      local message = "Resource is configured."
                      if obj.status and obj.status.users ~= nil then
                        message = "Resource is in use."
                      end
                      return create_health_status(HEALTH_STATUS.HEALTHY, message)
                    end
                    
                    return nil
                  end
                  
                  -- Check critical conditions that indicate degraded health
                  local function check_critical_conditions(conditions)
                    for _, condition in ipairs(conditions) do
                      if contains(CRITICAL_CONDITION_TYPES, condition.type) then
                        if condition.status == "False" then
                          local message = condition.message or ("Condition " .. condition.type .. " is False")
                          return create_health_status(HEALTH_STATUS.DEGRADED, message)
                        end
                      end
                    end
                    return nil
                  end
                  
                  -- Check for healthy conditions
                  local function check_healthy_conditions(conditions)
                    for _, condition in ipairs(conditions) do
                      if contains(HEALTHY_CONDITION_TYPES, condition.type) then
                        if condition.status == "True" then
                          return create_health_status(HEALTH_STATUS.HEALTHY, "Resource is up-to-date.")
                        end
                      end
                    end
                    return nil
                  end
                  
                  -- Main health check logic
                  local function determine_health_status()
                    -- Input validation
                    if not obj then
                      return create_health_status(HEALTH_STATUS.DEGRADED, "Resource object is nil")
                    end
                    
                    -- Handle resources without status
                    local result = handle_resources_without_status()
                    if result then
                      return result
                    end
                    
                    -- Handle ProviderConfig specially
                    result = handle_provider_config()
                    if result then
                      return result
                    end
                    
                    -- Handle resources with revision checks
                    result = handle_resources_with_revision_checks()
                    if result then
                      return result
                    end

                    -- If no status or conditions, default to progressing
                    if not obj.status or not obj.status.conditions then
                      return DEFAULT_HEALTH_STATUS
                    end
                    
                    -- Check critical conditions first (they take precedence)
                    result = check_critical_conditions(obj.status.conditions)
                    if result then
                      return result
                    end
                    
                    -- Check for healthy conditions
                    result = check_healthy_conditions(obj.status.conditions)
                    if result then
                      return result
                    end
                    
                    -- Default case: still progressing
                    return DEFAULT_HEALTH_STATUS
                  end
                  
                  -- Execute the health check and return the result
                  return determine_health_status()
              
          cmp:
            create: true
            plugins:
              envsubst:
                init:
                  command: [sh]
                  args: ["-c", 'echo "Initializing..."']
                generate:
                  command: [sh, -c, "/usr/local/bin/envsubst-plugin.sh"]
                discover:
                  filename: "kustomization.yaml"

        # Configure the Argo CD server
        server:
          # Enable high availability for the server
          replicas: 2
          
          # Resource configuration
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          
          # Anti-affinity to spread replicas across nodes and require critical addon nodes
          nodeSelector: {node-type: system}
          tolerations:
          - key: CriticalAddonsOnly
            operator: Exists
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
              - weight: 100
                podAffinityTerm:
                  labelSelector:
                    matchLabels:
                      app.kubernetes.io/name: argocd-server
                  topologyKey: kubernetes.io/hostname
          
          # Enable metrics for monitoring
          metrics:
            enabled: true
            serviceMonitor:
              enabled: false  # Enable if you have Prometheus operator
          
          # Configure OIDC if needed (can be enabled later)
          config:      
            # URL configuration
            url: "https://argocd.${CLUSTER_FQDN}"
            
            # Application instance label key
            application.instanceLabelKey: argocd.argoproj.io/instance

        # Configure the repository server
        repoServer:
          replicas: 2
          
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          
          nodeSelector: {node-type: system}
          tolerations:
          - key: CriticalAddonsOnly
            operator: Exists
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
              - weight: 100
                podAffinityTerm:
                  labelSelector:
                    matchLabels:
                      app.kubernetes.io/name: argocd-repo-server
                  topologyKey: kubernetes.io/hostname
          
          metrics:
            enabled: true
            serviceMonitor:
              enabled: false
          
          initContainers:
            - name: install-envsubst
              image: debian:stable-slim
              command: ["/bin/sh", "-c"]
              args:
              - echo "Installing envsubst...";
                apt-get update -y && apt-get install gettext daemontools -y;
                cp -v /usr/bin/envsubst /usr/bin/envdir /custom-tools/;
                echo "Done.";
              volumeMounts:
              - mountPath: /custom-tools
                name: custom-tools
              resources:
                limits:
                  memory: "200Mi"
                  cpu: "100m"
                requests:
                  memory: "100Mi"
                  cpu: "100m"
          
          extraContainers:
            # Create Envsubst Plugin container used for envsubst on resource files
            - name: envsubst
              securityContext:
                runAsNonRoot: true
                #Bug work-around. Change this back to 999 in the future
                runAsUser: 999
              image: quay.io/argoproj/argocd:v3.1.8
              command: [/var/run/argocd/argocd-cmp-server]
              args:
                - --loglevel
                - debug
              volumeMounts:
                - mountPath: /var/run/argocd
                  name: var-files
                - mountPath: /home/argocd/cmp-server/plugins
                  name: plugins
                - mountPath: /home/argocd/cmp-server/config/plugin.yaml
                  subPath: envsubst.yaml
                  name: argocd-cmp-cm
                - mountPath: /tmp
                  name: cmp-tmp
                - mountPath: /usr/local/bin/envsubst
                  name: custom-tools
                  subPath: envsubst
                - mountPath: /usr/local/bin/envdir
                  name: custom-tools
                  subPath: envdir
                - mountPath: /usr/local/bin/envsubst-plugin.sh
                  name: envsubst-plugin
                  subPath: envsubst-plugin.sh
                - mountPath: /home/argocd/cmp-server/config/env
                  name: envsubst-env-vars # TODO: verify if this is still corect
                - mountPath: /custom-tools
                  name: custom-tools
              resources:
                limits:
                  memory: "200Mi"
                  cpu: "100m"
                requests:
                  memory: "100Mi"
                  cpu: "100m"
              envFrom:
                - configMapRef:
                    name: envsubst-env-vars
          
          volumes:
            - configMap:
                name: envsubst-plugin
                defaultMode: 0755
              name: envsubst-plugin
            - configMap:
                name: envsubst-env-vars
              name: envsubst-env-vars
            - configMap:
                name: argocd-cmp-cm
              name: argocd-cmp-cm
            - emptyDir: {}
              name: cmp-tmp
            - emptyDir: {}
              name: custom-tools

        # Configure the application controller
        controller:
          replicas: 1  # Can be increased for larger clusters
          
          # Require critical addon nodes for ArgoCD controller
          nodeSelector: {node-type: system}
          tolerations:
          - key: CriticalAddonsOnly
            operator: Exists
          affinity:
          
          resources:
            limits:
              cpu: 1000m
              memory: 1536Mi
            requests:
              cpu: 500m
              memory: 768Mi
          
          metrics:
            enabled: true
            serviceMonitor:
              enabled: false

        redisSecretInit:  
          nodeSelector: {node-type: system}
          tolerations: [{key: "CriticalAddonsOnly", operator: "Exists"}]

        # Configure Redis for caching (used in HA mode)
        redis:
          enabled: true
          
          # Require critical addon nodes for Redis
          nodeSelector: {node-type: system}
          tolerations:
          - key: CriticalAddonsOnly
            operator: Exists
          
          # Redis HA configuration
          ha:
            enabled: false

        # Configure Dex for OIDC (if using external OIDC)
        dex:
          enabled: false  # Enable if you need Dex for OIDC
          nodeSelector: {node-type: system}
          tolerations:
          - key: CriticalAddonsOnly
            operator: Exists

        # Notifications controller (optional)
        notifications:
          enabled: true
          nodeSelector: {node-type: system}
          tolerations:
          - key: CriticalAddonsOnly
            operator: Exists

        # ApplicationSet controller
        applicationSet:
          enabled: true
          nodeSelector: {node-type: system}
          tolerations:
          - key: CriticalAddonsOnly
            operator: Exists

  destination:
    server: https://kubernetes.default.svc
    namespace: argocd
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
      - ServerSideApply=true
