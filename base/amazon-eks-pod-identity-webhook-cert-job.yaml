apiVersion: v1
kind: ServiceAccount
metadata:
  name: webhook-cert-generator
  namespace: kube-system
  annotations:
    argocd.argoproj.io/sync-wave: "3"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: webhook-cert-generator
  namespace: kube-system
  annotations:
    argocd.argoproj.io/sync-wave: "3"
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "get", "patch", "update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: webhook-cert-generator
  annotations:
    argocd.argoproj.io/sync-wave: "3"
rules:
- apiGroups: ["admissionregistration.k8s.io"]
  resources: ["mutatingwebhookconfigurations"]
  verbs: ["get", "patch", "update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: webhook-cert-generator
  namespace: kube-system
  annotations:
    argocd.argoproj.io/sync-wave: "3"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: webhook-cert-generator
subjects:
- kind: ServiceAccount
  name: webhook-cert-generator
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: webhook-cert-generator
  annotations:
    argocd.argoproj.io/sync-wave: "3"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: webhook-cert-generator
subjects:
- kind: ServiceAccount
  name: webhook-cert-generator
  namespace: kube-system
---
apiVersion: batch/v1
kind: Job
metadata:
  name: webhook-cert-generator
  namespace: kube-system
  annotations:
    argocd.argoproj.io/sync-wave: "3"
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      name: webhook-cert-generator
    spec:
      serviceAccountName: webhook-cert-generator
      restartPolicy: OnFailure
      containers:
      - name: cert-generator
        image: alpine/openssl:latest
        command:
        - /bin/sh
        - -c
        - |
          set -e
          
          # Check if secret already exists
          if kubectl get secret amazon-eks-pod-identity-webhook-cert -n kube-system 2>/dev/null; then
            echo "Certificate secret already exists, skipping generation"
            exit 0
          fi
          
          # Generate private key
          openssl genrsa -out /tmp/tls.key 2048
          
          # Generate certificate signing request and self-signed certificate
          # Valid for 10 years, covering the webhook service DNS names
          openssl req -new -x509 -key /tmp/tls.key -out /tmp/tls.crt -days 3650 \
            -subj "/CN=amazon-eks-pod-identity-webhook.kube-system.svc" \
            -addext "subjectAltName=DNS:amazon-eks-pod-identity-webhook.kube-system.svc,DNS:amazon-eks-pod-identity-webhook.kube-system.svc.cluster.local"
          
          # Extract CA bundle (same as cert for self-signed)
          CA_BUNDLE=$(cat /tmp/tls.crt | base64 | tr -d '\n')
          
          # Create Kubernetes secret
          kubectl create secret tls amazon-eks-pod-identity-webhook-cert \
            --cert=/tmp/tls.crt \
            --key=/tmp/tls.key \
            -n kube-system
          
          # Add CA bundle as annotation for easy retrieval
          kubectl annotate secret amazon-eks-pod-identity-webhook-cert \
            -n kube-system \
            "ca-bundle=${CA_BUNDLE}"
          
          echo "Certificate generated and stored successfully"
        volumeMounts:
        - name: kubectl
          mountPath: /usr/local/bin/kubectl
          subPath: kubectl
      initContainers:
      - name: install-kubectl
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          apk add --no-cache curl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          mv kubectl /kubectl-bin/kubectl
        volumeMounts:
        - name: kubectl
          mountPath: /kubectl-bin
      volumes:
      - name: kubectl
        emptyDir: {}
      # Run on system nodes with critical addons
      nodeSelector:
        node-type: system
      tolerations:
      - key: CriticalAddonsOnly
        operator: Exists
